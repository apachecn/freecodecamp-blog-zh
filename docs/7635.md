# Unix 环境下的程序设计:学术文章摘要

> 原文：<https://www.freecodecamp.org/news/program-design-in-the-unix-environment-a-summary-cadcb8816dcf/>

今天我们来看看 Pike 和 Kernighan 在 1983 年出版的《[Unix 环境下的程序设计](http://harmful.cat-v.org/cat-v/unix_prog_design.pdf)》一书。

论文开篇列举了 Unix 成功的原因，然后评论了 Unix 的哲学和它的好处。它通过查看程序偏离 Unix 哲学的例子并讨论由此产生的权衡来做到这一点

Unix 成功的原因:

1.  可移植性:内核和应用程序是用 C 语言编写的，所以它们可以在系统之间移动，而不需要用特定于该系统的汇编语言重写。
2.  相同的操作系统运行在不同的硬件上，所以用户已经很熟悉了，当新的硬件发布时，不必重新学习。
3.  尽管硬件发生了变化，但供应商可以在每台机器上安装相同的软件。
4.  这个系统不是太大，而且很容易修改，因为所有的东西都是用 c 写的。
5.  它基于通用工具的使用提供了一种新的理念。他们做好一件事，并可以结合起来做一个特定的任务，而不是创造巨大的单一工具，只为一个目的服务。

本文认为工具的使用和设计是密切相关的，如何将它们结合在一起是本文的主题。

然后，本文将深入探讨`cat`(用于连接和打印文件的 Unix 命令行实用程序)。它将输入复制到输出。输入通常是一个或多个文件的序列或标准输入。输出是文件或标准输出。

`cat`的主要目的是作为一个连接文件的工具。它可以与管道(`|`)操作符结合使用，通过输出重定向进一步增强和扩展它的效用。

另一方面，其他系统试图将一堆相关的功能转储到一个命令中，这违背了 Unix 的理念。它还锁定了可能对其他程序有用的功能。

Unix 方法的优势:

1.  外壳和它可以调用的程序提供了对系统设施的统一访问。对于每个命令，shell 以相似的方式扩展文件名参数。因为有了管道，我们不需要每个命令都处理输入的前后处理。
2.  当职能划分清楚时，增长就容易了。

示例:添加`( backtic)运算符是为了将一个程序的输出转换为另一个程序的输入，而不需要对 shell 解释的任何其他程序进行更改。shell 调用的所有程序都会自动获得这个特性。如果每个需要这个特性的程序都去解释它，那么就很难实施统一性和进行进一步的实验，因为每个新的想法都会影响所有想要使用它的程序。

然而，在`cat`的未来版本中，引入了许多新的选项(比如打印行号和不可打印的字符)。

作者认为，与其将这些选项添加到`cat`本身，还不如使用现有的程序或者创建新的程序。例如，行号功能可以通过使用`pr`来提供。然而，没有程序允许打印不可打印的字符，这保证了一个新的创造。

> 这样的修改混淆了`cat`的工作是连接文件和
> 在终端上显示文件这种常见的特殊情况下发生的事情。一个 UNIX 程序应该做好一件事，把不相关的任务留给其他程序。`cat`的工作是收集文件中的数据。收集数据的程序不应该改变数据；`cat`因此不该变换其输入。

每当我们把一个东西分成多个程序时，我们就牺牲了一些效率。但是由于`cat`通常不带任何选项，所以让最常见的情况最有效是有意义的。

> 单独的计划并不总是比更广泛的选择更好；哪个更好要看问题。每当一个人需要一种执行新功能的方法时，他就面临着是增加一个新选项还是编写一个新程序的选择(假设没有一个可编程工具能方便地完成这项工作)。做出选择的指导原则应该是每个程序做一件事。选项被适当地添加到已经具有正确功能的程序中。如果没有这样的程序，那么就需要一个新的程序。在这种情况下，应该使用程序设计的通常标准:程序应该尽可能通用，它的默认行为应该与最常见的用法相匹配，它应该与其他程序相配合。

让我们考虑另一个问题:处理快速终端线路。我们如何处理从屏幕顶部滚出来的输出？

有两种方法:

1.  告诉每个命令有关终端的属性，以便它做正确的事情
2.  编写一个只处理终端而不修改其他程序的命令

让我们考虑两种方法的例子:`lsc`和`ls`，它们打印出目录中的文件列表。

`lsc`根据输入改变其输出。它在屏幕上以柱状的方式显示列表，这样如果输出到终端，o/p 就合适了。`ls`在一列中显示所有内容。

> 通过将单列输出保留到文件或管道中，`lsc` 确保了与像`grep` 或`wc` 这样的程序的兼容性，这些程序希望每行打印一个内容。这种根据目的地对输出格式的特别调整不仅令人不快，而且是独一无二的没有标准 UNIX 命令具有这种特性。

作者认为列化工具总体上是有用的，不应该仅仅被锁在`lsc`中，使其他程序无法访问它。他们主张一个不同的计划，其主要工作是集中。

> 类似的推理为数据流出屏幕(列化或非列化)这一普遍问题提出了一个解决方案:一个单独的程序接受任何输入，并一次在一个屏幕上打印出来。这样的节目现在已经广为流传，以 pg 等名字命名。该解决方案不影响其他程序，但可以用于所有程序。像往常一样，一旦基本功能是正确的，该计划可以加强与选项…

基于前面的例子，作者还讨论了一些不同的情况，其中一些功能被锁定在一个特定的程序中(比如终端中的输入历史)，作为一个中心服务会更好。所有的交互式程序都可以从中受益。

他们的结论是，在 Unix 中用特性/选项扩充现有命令是不可取的，这违背了它的基本理念:让程序做好一件事。可以编写几个这样的程序来完成更复杂的任务。

> 在 UNIX 系统上解决问题的关键是识别正确的原语操作，并将它们放在正确的位置。UNIX 程序倾向于解决一般问题，而不是特殊情况。从非常宽泛的意义上来说，这些程序是正交的，跨越了要做的工作的空间(尽管出于历史、方便或效率的原因，有相当多的重叠)。函数被放在它们能发挥最大作用的地方:不应该在每个产生输出的程序中都有一个分页器，就像不应该在每个使用文件名的程序中都有文件名模式匹配一样。

> UNIX 不需要的一点是更多的特性。它之所以成功，部分原因是因为它有一些很好的想法，这些想法能够很好地协同工作。仅仅增加功能并不能让用户做事情更容易，只会让手册更厚。在正确的地方找到正确的解决方案总是比随意的黑客攻击更有效。