# CSS 不是黑魔法

> 原文：<https://www.freecodecamp.org/news/its-not-dark-magic-pulling-back-the-curtains-from-your-stylesheets-c8d677fa21b2/>

由 aimeemarieknight

# CSS 不是黑魔法

#### 拉开样式表上的窗帘

![HTLeseY5v-uus9eTzCqV9gMAvHIGKPM3JQCi](img/343ff02c0f660a88415e22bf27bf3b03.png)

如果你是一名 web 开发人员，你可能会时不时地写一些 CSS。

当你第一次看 CSS 的时候，它可能看起来很容易。你在这里添加了一些边框，在那里改变了一些颜色。JavaScript 是前端开发的难点，对吧？

在你作为 web 开发人员的发展过程中，这种情况发生了变化！更糟糕的是，前端社区中的许多开发人员已经开始将 CSS 视为一种玩具语言。

然而事实是，当我们碰壁时，我们中的许多人实际上并不明白我们的 CSS 在做什么。

在训练营结束后的头两年，我做了全栈 JavaScript，并在各处加入了一些 CSS。作为 JavaScript Jabber T1 的一名成员，我一直觉得 JavaScript 是我的面包和黄油，所以它是我花费最多时间的东西。

然而，去年我决定专注于前端，我意识到我不能像调试 JavaScript 那样调试我的样式表！

我们都喜欢拿它开玩笑，但我们中有多少人真正花时间去尝试和理解我们正在编写或阅读的 CSS 呢？当我们碰壁时，有多少人真正合理地将问题调试到下一个最低的抽象层？相反，我们满足于第一个 StackOverflow 答案，hacks，或者我们只是让这个问题完全消失。

当浏览器以他们没有预料到的方式呈现 CSS 时，开发人员经常会感到困惑。这不是黑魔法，作为开发者，我们知道计算机只是在解析我们的指令。

内部知识对于高级调试和性能调优也很有用。虽然许多会议讨论如何修复常见的错误，但我的演讲(和这篇文章)将通过深入探究浏览器内部来了解我们的样式是如何解析和呈现的，从而关注原因。

### DOM 和 CSSOM

首先，理解浏览器包含 JavaScript 引擎和渲染引擎是很重要的。我们将重点讨论后者。例如，我们将讨论与 WebKit (Safari)、Blink (Chrome)、Gecko (Firefox)和 Trident/EdgeHTML (IE/Edge)相关的细节。浏览器将经历一个过程，包括转换、标记化、词法分析和解析，最终构建 DOM 和 CSSOM。

从较高的层面来看，您可以将它们理解为:

*   **转换**:从磁盘或网络上读取 HTML 和 CSS 的原始字节。
*   **标记化**:将输入分成块(例如:开始标签、结束标签、属性名、属性值)，去除不相关的字符，例如空格和换行符。
*   **Lexing** :类似于记号赋予器，但它也标识每个记号的类型(这个记号是一个数字，那个记号是一个字符串文字，另一个记号是一个相等运算符)。
*   **解析**:从词法分析器中获取标记流，使用特定的语法解释标记，并将其转换为抽象语法树。

一旦创建了这两种树结构，作为布局过程的一部分，渲染引擎就将数据结构附加到所谓的渲染树中。

渲染树是文档的可视化表示，它能够以正确的顺序绘制页面内容。渲染树的构建遵循以下顺序:

*   从 DOM 树的根开始，遍历每个可见的节点。
*   省略不可见的节点。
*   对于每个可见节点，找到合适的匹配 CSSOM 规则并应用它们。
*   发出包含内容及其计算样式的可见节点。
*   最后，输出一个包含屏幕上所有可见内容的内容和样式信息的渲染树。

CSSOM 对渲染树有很大的影响，但对 DOM 树没有影响。

### 翻译

在布局和渲染树构建之后，浏览器最终可以进行屏幕的实际绘制和合成。让我们花一点时间来区分这里的一些术语。

*   **布局**:包括计算一个元素将占据多少空间以及它在屏幕上的位置。父元素可以影响子元素，有时反之亦然。
*   **绘画**:将渲染树中的每个节点转化为屏幕上实际像素的过程。它包括绘制文本、颜色、图像、边框和阴影。绘制通常在多个层上完成，多轮绘制可能是由于加载了改变 DOM 的 JavaScript 而导致的。
*   **合成**:将所有图层拼合为屏幕上可见的最终图像的动作。由于页面的各个部分可以被绘制到多个层中，所以它们需要以正确的顺序被绘制到屏幕上。

绘制时间因渲染树构造而异，元素的宽度和高度越大，绘制时间就越长。

添加不同的效果也可以增加绘画时间。绘画遵循元素在其堆叠上下文中堆叠的顺序(从后到前)，我们将在稍后讨论 z-index 时进入该顺序。如果你是视觉学习者，有一个很棒的绘画演示。

当人们谈到浏览器中的硬件加速时，他们几乎总是指加速合成，这意味着使用 GPU 来合成网页内容。

与使用计算机 CPU 的旧方法相比，合成允许相当大的速度增加。will-change 属性是一个可以利用这一点添加的属性。

例如，当使用 CSS 转换时，will-change 属性允许向浏览器暗示一个 DOM 元素将在不久的将来被转换。这使得能够将一些绘制和合成操作卸载到 GPU 上，这可以大大提高具有大量动画的页面的性能。它对滚动位置、内容、不透明度和顶部或左侧定位有类似的增益。

了解某些属性会导致重新布局，而其他属性只会导致重画，这一点很重要。当然，从性能角度来看，如果你只能触发重画，那是最好的。

例如，改变元素的颜色只会重画该元素，而改变元素的位置会导致布局和重画该元素，它的子元素和可能的兄弟元素。添加一个 DOM 节点将导致节点的布局和重画。主要的改变，比如增加 html 元素的字体大小，会导致整个树的重新布局和重画。

如果你和我一样，你可能比 CSSOM 更熟悉 DOM，所以让我们深入了解一下。值得注意的是，默认情况下，CSS 被视为渲染阻塞资源。这意味着浏览器将保存任何其他进程的呈现，直到构建了 CSSOM。

CSSOM 与 DOM 也不是一一对应的。显示无、脚本标签、meta 标签、head 元素等。因为它们没有反映在渲染输出中。

CSSOM 和 DOM 的另一个区别是 CSS 解析使用上下文无关的语法。换句话说，呈现引擎没有像解析 HTML 以创建 DOM 时那样填充 CSS 缺少的语法的代码。

当解析 HTML 时，浏览器必须考虑周围的字符，它需要的不仅仅是规范，因为标记可能包含缺失的信息，但无论如何仍需要呈现。

说了这么多，让我们回顾一下。

*   浏览器发送对页面的 HTTP 请求
*   Web 服务器发送响应
*   浏览器通过令牌化将响应数据(字节)转换为令牌
*   浏览器将令牌转化为节点
*   浏览器将节点变成 DOM 树
*   等待 CSSOM 树构造

### 特征

现在我们对浏览器的工作原理有了更好的理解，让我们来看看开发人员更容易混淆的地方。首先，特异性。

在一个非常基本的层面上，我们知道特异性仅仅意味着以正确的级联顺序应用规则。使用 CSS 选择器有很多方法来定位一个特定的标签，浏览器需要一种方法来协商给一个特定的标签指定什么样式。浏览器通过首先计算每个选择器的特异性值来做出这个决定。

不幸的是，特异性计算困扰了许多 JavaScript 开发人员，所以让我们更深入地了解一下这种计算是如何进行的。我们将使用一个带有“容器”类的 div 示例。嵌套在这个 div 中的是另一个 id 为“main”的 div。在里面我们会有一个包含锚定标签的 p 标签。不用提前偷看，你知道锚标签会是什么颜色吗？

```
#main a {   color: green;}
```

```
p a {   color: yellow;}
```

```
.container #main a {  color: pink;}
```

```
div #main p a {   color: orange;}
```

```
a {   color: red;}
```

答案是粉色，数值为 1，1，1。以下是剩余的结果:

*   `div #main p a: 1,0,3`
*   `#main a: 1,0,1`
*   `p a: 2`
*   `a: 1`

要确定该数字，您需要计算以下内容:

*   **第一个数字**:ID 选择器的数量。
*   **第二个数**:类选择器，属性选择器(例如:`[type="text"]`，`[rel="nofollow"]`)，伪类(例如:`:hover`，`:visited`)的个数。
*   **第三个数**:类型选择器和伪元素的个数(例如:`::before`、`::after`)。

所以，对于这样的选择器:

```
#header .navbar li a:visited
```

值将是 1，2，2，因为我们有一个 ID、一个类、一个伪类和两个类型选择器(`li`、`a`)。你可以把这些值当成一个数字来读，比如 1，2，2 是 122。逗号是用来提醒你这不是一个十进制系统。从技术上讲，你可以有一个 0，1，13，4 和 13 的特异性值，不会像 10 进制那样溢出。

### 配置

第二，我想花点时间讨论一下定位。正如我们在这篇文章前面看到的，定位和布局是密切相关的。

布局是一个递归过程，可以在整个渲染树上触发，作为全局样式更改的结果，或者以增量方式进行，其中只对页面的脏部分进行布局。如果我们回想一下渲染树，有一件有趣的事情值得注意:使用绝对定位，被布局的对象被放在渲染树中与 DOM 树不同的位置。

我也经常被问到使用 flexbox 还是 floats。当然，从可用性的角度来看，flexbox 很棒，但是当应用于相同的元素时，flexbox 布局将在大约 3.5 毫秒内呈现，而浮动布局可能需要大约 14 毫秒。因此，保持你的 CSS 技能就像保持你的 JavaScript 技能一样值得。

### z 指数

最后，我想讨论一下 z-index。起初，这听起来很简单。HTML 文档中的每个元素都可以位于文档中其他元素的前面或后面。它也只对定位的元素有效。如果您试图在没有指定位置的元素上设置 z 索引，它不会做任何事情。

调试 z 索引问题的关键是理解堆叠上下文，并且总是从堆叠上下文根元素开始。堆叠上下文只是 HTML 元素沿着相对于面向视口的用户的虚拟 z 轴的三维概念化。换句话说，它是具有共同父元素的元素组，它们一起向前或向后移动。

每个堆叠上下文都有一个 HTML 元素作为其根元素，当不涉及 z-index 和 position 属性时，规则很简单。堆叠顺序与在 HTML 中出现的顺序相同。

但是，您可以使用 z-index 之外的属性创建新的堆叠上下文，这就是事情变得复杂的地方。不透明度，当它的值小于 1 时，滤镜，当它的值不是 n one 时，mix-blend-mode，当它的值不是 normal 时，实际上会创建新的堆叠上下文。

提醒一下，混合模式决定了特定图层上的像素如何与它下面图层上的可见像素交互。

当 transform 属性的值不为 none 时，它也会触发新的堆叠上下文。比如`scale(1)`和`translate3d(0,0,0)`。再次提醒，scale 属性用于调整大小，translate3d 触发 GPU 对 CSS 过渡进行操作，使其更加平滑。

所以，你可能仍然没有设计的眼光，但是希望现在你已经是一个 CSS 大师了！如果你有兴趣更进一步，我已经编译了额外的资源，我也在这里使用了。